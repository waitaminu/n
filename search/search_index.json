{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Accueil \u2693\ufe0e Bienvenue sur le site de cours et d'activit\u00e9s de la sp\u00e9cialit\u00e9 INFO du lyc\u00e9e. For full documentation visit mkdocs.org . Commands \u2693\ufe0e mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout \u2693\ufe0e mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Accueil"},{"location":"#accueil","text":"Bienvenue sur le site de cours et d'activit\u00e9s de la sp\u00e9cialit\u00e9 INFO du lyc\u00e9e. For full documentation visit mkdocs.org .","title":"Accueil"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"Diviser%20pour%20r%C3%A9gner/cours/","text":"Diviser pour r\u00e9gner \u2693\ufe0e 1. Retour sur l'algorithme de recherche par dichotomie \u2693\ufe0e Nous avons d\u00e9j\u00e0 vu l'algorithme de recherche par dichotomie (du grec dikhotomia , \u00ab division en deux parties \u00bb). Notre but ici est la recherche de la pr\u00e9sence (ou non) d'un \u00e9l\u00e9ment dans un tableau tri\u00e9e . Notre fonction renverra donc un bool\u00e9en. La recherche na\u00efve (\u00e9l\u00e9ment par \u00e9l\u00e9ment) est naturellement de complexit\u00e9 lin\u00e9aire. Nous allons voir que la m\u00e9thode dichotomique est plus efficace. 1.1. Version imp\u00e9rative \u2693\ufe0e Dichotomie version imp\u00e9rative 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def recherche_dichotomique ( tableau : list , valeur_cherchee : int ) -> bool : \"\"\"renvoie True si valeur_cherchee est dans le tableau, d\u00e9j\u00e0 tri\u00e9, et False si valeur_cherchee ne s'y trouve pas. \"\"\" indice_debut = 0 indice_fin = len ( tableau ) - 1 while indice_debut <= indice_fin : indice_central = ( indice_debut + indice_fin ) // 2 # 1 valeur_centrale = tableau [ indice_central ] # 2 if valeur_centrale == valeur_cherchee : # 3 return True if valeur_centrale < valeur_cherchee : # 4 indice_debut = indice_central + 1 else : indice_fin = indice_central - 1 return False # 5 on calcule l'indice central on d\u00e9termine la valeur centrale si la valeur centrale est la valeur cherch\u00e9e... si la valeur centrale est trop petite... la valeur_cherchee ne se trouve pas dans tableau Exemple d'utilisation : >>> t = [ 2 , 3 , 6 , 7 , 11 , 14 , 18 , 19 , 24 ] >>> recherche_dichotomique ( t , 7 ) True >>> recherche_dichotomique ( t , 35 ) False \u00c0 chaque tour de la boucle while , la taille de la liste est divis\u00e9e par 2. Ceci conf\u00e8re \u00e0 cet algorithme une complexit\u00e9 logarithmique (bien meilleure qu'une complexit\u00e9 lin\u00e9aire). 1.2. Version r\u00e9cursive \u2693\ufe0e Il est possible de programmer de mani\u00e8re r\u00e9cursive la recherche dichotomique sans toucher au tableau, comme on pourrait le faire en utilisant le slicing, et donc en jouant uniquement sur les indices : Dichotomie version r\u00e9cursive 1 2 3 4 5 6 7 8 9 10 11 12 def dicho_rec ( tableau , valeur_cherchee , indice_debut = 0 , indice_fin = None ): if indice_fin is None : indice_fin = len ( tableau ) - 1 if indice_debut > indice_fin : return False indice_central = ( indice_debut + indice_fin ) // 2 if tableau [ indice_central ] < valeur_cherchee : return dicho_rec ( tableau , valeur_cherchee , indice_central + 1 , indice_fin ) elif tableau [ indice_central ] > valeur_cherchee : return dicho_rec ( tableau , valeur_cherchee , indice_debut , indice_central - 1 ) else : return True Pour pouvoir appeler simplement la fonction sans avoir \u00e0 pr\u00e9ciser les indices, on leur donne des param\u00e8tres par d\u00e9faut. Il est impossible de donner indice_fin = len(tableau) - 1 par d\u00e9faut (car tableau est aussi un param\u00e8tre). On passe donc par une autre valeur (ici None ) qu'on va ici intercepter. Exemple d'utilisation : >>> t = [ 2 , 3 , 6 , 7 , 11 , 14 , 18 , 19 , 24 ] >>> dicho_rec ( t , 7 ) True >>> dicho_rec ( t , 35 ) False Visualisation gr\u00e2ce \u00e0 PythonTutor: 2. Diviser pour r\u00e9gner \u2693\ufe0e Les algorithmes de dichotomie pr\u00e9sent\u00e9s ci-dessus ont tous en commun de diviser par deux la taille des donn\u00e9es de travail \u00e0 chaque \u00e9tape. Cette m\u00e9thode de r\u00e9solution d'un probl\u00e8me est connue sous le nom de diviser pour r\u00e9gner , ou divide and conquer en anglais. Une d\u00e9finition pourrait \u00eatre : D\u00e9finition Un probl\u00e8me peut se r\u00e9soudre en employant le paradigme diviser pour r\u00e9gner lorsque : - il est possible de d\u00e9composer ce probl\u00e8me en sous-probl\u00e8mes ind\u00e9pendants - la taille de ces sous-probl\u00e8mes est une fraction du probl\u00e8me initial Remarques : Les sous-probl\u00e8mes peuvent n\u00e9cessiter d'\u00eatre ensuite recombin\u00e9s entre eux (voir plus bas le tri fusion). Consid\u00e9rons l'\u00e9criture r\u00e9cursive de la fonction factorielle ci-dessous : def factorielle ( n ): if n == 0 : return 1 else : return n * factorielle ( n - 1 ) On ne peut pas parler ici de diviser pour r\u00e9gner car la taille des donn\u00e9es \u00e0 traiter est pass\u00e9e de n \u00e0 n-1 . C'est bien une diminution (qui fait que l'algorithme fonctionne) mais il n'y a pas de division de la taille des donn\u00e9es. C'est cette division (par 2 dans le cas de la dichotomie) qui donne son efficacit\u00e9 \u00e0 ce paradigme. Le paradigme diviser pour r\u00e9gner va naturellement amener \u00e0 r\u00e9diger des programmes r\u00e9cursifs. 3. L'exponentiation rapide \u2693\ufe0e On appelle exponentiation le fait de mettre en puissance un nombre. On va donc coder, de deux mani\u00e8res diff\u00e9rentes, la puissance d'un nombre. 3.1. Algorithme classique \u2693\ufe0e Exponentiation classique 1 2 3 4 5 def puissance ( a , n ): if n == 0 : return 1 else : return a * puissance ( a , n - 1 ) 3.2. Algorithme utilisant diviser pour r\u00e9gner \u2693\ufe0e Nous allons nous appuyer sur la remarque math\u00e9matique suivante : Pour tout nombre \\(a\\) , si \\(n\\) est pair, \\(a^n = (a^2)^{\\frac{n}{2}}\\) si \\(n\\) est impair, \\(a^n = a \\times a^{n-1} = a \\times (a^2)^{\\frac{n-1}{2}}\\) Ainsi, dans le cas o\u00f9 \\(n\\) est pair, il suffit d'\u00e9lever \\(a\\) au carr\u00e9 (une seule op\u00e9ration) pour que l'exposant diminue de moiti\u00e9 . On peut donc programmer la fonction puissance en utilisant le paradigme diviser pour r\u00e9gner : Exponentiation rapide 1 2 3 4 5 6 7 def puissance_mod ( a , n ): if n == 0 : return 1 if n % 2 == 0 : return puissance_mod ( a ** 2 , n // 2 ) else : return a * puissance_mod ( a ** 2 , ( n - 1 ) // 2 ) 3.3. Comparaison de la vitesse d'ex\u00e9cution des deux algorithmes \u2693\ufe0e Exercice \u00c9nonc\u00e9 Recr\u00e9er le graphique ci-dessus, qui compare les temps d'ex\u00e9cution des deux fonctions puissance et puissance_mod . Aide pour Matplotlib : le code ci-dessous 1 2 3 4 5 6 7 8 9 import matplotlib.pyplot as plt def carre ( x ): return x ** 2 x = list ( range ( 10 )) y = [ carre ( k ) for k in x ] plt . plot ( x , y ) plt . show () donne le graphique suivant : 4. Le tri-fusion \u2693\ufe0e En anglais le merge sort . 4.1. Pr\u00e9ambule : l'interclassement \u2693\ufe0e Le m\u00e9canisme principal du tri fusion est la fusion de deux listes tri\u00e9es en une nouvelle liste elle aussi tri\u00e9e. On appelera ce m\u00e9canisme l' interclassement . Principe de l'interclassement de deux listes lst1 et lst2 . on part d'une liste vide lst_totale on y ajoute alternativement les \u00e9l\u00e9ments de lst1 et lst2 . Il faut pour cela g\u00e9rer s\u00e9par\u00e9ment un indice i1 pour la liste lst1 et un indice i2 pour la liste i2 . quand une liste est \u00e9puis\u00e9e, on y ajoute la totalit\u00e9 restante de l'autre liste. Exercice \u00c9nonc\u00e9 Correction Coder la fonction interclassement . def interclassement ( lst1 , lst2 ): i1 = 0 i2 = 0 lst_totale = [] while i1 != len ( lst1 ) and i2 != len ( lst2 ): if lst1 [ i1 ] < lst2 [ i2 ]: lst_totale . append ( lst1 [ i1 ]) i1 += 1 else : lst_totale . append ( lst2 [ i2 ]) i2 += 1 return lst_totale + lst1 [ i1 :] + lst2 [ i2 :] 4.2. La fusion \u2693\ufe0e 4.2.1. Principe \u2693\ufe0e L'id\u00e9e du tri fusion est le d\u00e9coupage de la liste originale en une multitude de listes ne contenant qu'un seul \u00e9l\u00e9ment. Ces listes \u00e9l\u00e9mentaires seront ensuite interclass\u00e9es avec la fonction pr\u00e9c\u00e9dente. Principe de l'algorithme du tri fusion : pour trier une liste, on interclasse les deux moiti\u00e9s de cette liste, pr\u00e9c\u00e9d\u00e9mment elles-m\u00eames tri\u00e9es par le tri fusion. si une liste \u00e0 trier est r\u00e9duite \u00e0 un \u00e9l\u00e9ment, elle est d\u00e9j\u00e0 tri\u00e9e. 4.2.2. Impl\u00e9mentation \u2693\ufe0e La grande force de ce tri va \u00eatre qu'il se programme simplement de mani\u00e8re r\u00e9cursive , en appelant \u00e0 chaque \u00e9tape la m\u00eame fonction mais avec une taille de liste divis\u00e9e par deux, ce qui justifie son classement parmi les algorithmes utilisant \u00abdiviser pour r\u00e9gner\u00bb. Algorithme de tri fusion ( merge sort ) def interclassement ( lst1 , lst2 ): lst_totale = [] n1 , n2 = len ( lst1 ), len ( lst2 ) i1 , i2 = 0 , 0 while i1 < n1 and i2 < n2 : if lst1 [ i1 ] < lst2 [ i2 ]: lst_totale . append ( lst1 [ i1 ]) i1 += 1 else : lst_totale . append ( lst2 [ i2 ]) i2 += 1 return lst_totale + lst1 [ i1 :] + lst2 [ i2 :] def tri_fusion ( lst ): if len ( lst ) <= 1 : return lst else : m = len ( lst ) // 2 return interclassement ( tri_fusion ( lst [: m ]), tri_fusion ( lst [ m :])) 4.2.3. Visualisation \u2693\ufe0e Une erreur classique avec les fonctions r\u00e9cursives est de consid\u00e9rer que les appels r\u00e9cursifs sont simultan\u00e9s. C'est faux ! L'animation suivante montre la progression du tri : Il est aussi conseill\u00e9 d'observer l'\u00e9volution de l'algorithme gr\u00e2ce \u00e0 PythonTutor : 4.3. Complexit\u00e9 \u2693\ufe0e La division par 2 de la taille de la liste pourrait nous amener \u00e0 penser que le tri fusion est de complexit\u00e9 logarithmique, comme l'algorithme de dichotomie. Il n'en est rien. En effet, l'instruction finale interclassement(tri_fusion(lst[:m]), tri_fusion(lst[m:])) lance deux appels \u00e0 la fonction tri_fusion (avec certe des donn\u00e9es d'entr\u00e9e deux fois plus petites). On peut montrer que : Complexit\u00e9 du tri fusion L'algorithme de tri fusion est en \\(O(n \\log n)\\) . On dit qu'il est semi-logarithmique . Une complexit\u00e9 semi-logarithmique (en \\(O(n \\log n)\\) ) se situe \u00abentre\u00bb une complexit\u00e9 lin\u00e9aire (en \\(O(n)\\) ) et une complexit\u00e9 quadratique (en \\(O(n^2)\\) ).","title":"Diviser pour r\u00e9gner"},{"location":"Diviser%20pour%20r%C3%A9gner/cours/#diviser-pour-regner","text":"","title":"Diviser pour r\u00e9gner"},{"location":"Diviser%20pour%20r%C3%A9gner/cours/#1-retour-sur-lalgorithme-de-recherche-par-dichotomie","text":"Nous avons d\u00e9j\u00e0 vu l'algorithme de recherche par dichotomie (du grec dikhotomia , \u00ab division en deux parties \u00bb). Notre but ici est la recherche de la pr\u00e9sence (ou non) d'un \u00e9l\u00e9ment dans un tableau tri\u00e9e . Notre fonction renverra donc un bool\u00e9en. La recherche na\u00efve (\u00e9l\u00e9ment par \u00e9l\u00e9ment) est naturellement de complexit\u00e9 lin\u00e9aire. Nous allons voir que la m\u00e9thode dichotomique est plus efficace.","title":"1. Retour sur l'algorithme de recherche par dichotomie"},{"location":"Diviser%20pour%20r%C3%A9gner/cours/#11-version-imperative","text":"Dichotomie version imp\u00e9rative 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def recherche_dichotomique ( tableau : list , valeur_cherchee : int ) -> bool : \"\"\"renvoie True si valeur_cherchee est dans le tableau, d\u00e9j\u00e0 tri\u00e9, et False si valeur_cherchee ne s'y trouve pas. \"\"\" indice_debut = 0 indice_fin = len ( tableau ) - 1 while indice_debut <= indice_fin : indice_central = ( indice_debut + indice_fin ) // 2 # 1 valeur_centrale = tableau [ indice_central ] # 2 if valeur_centrale == valeur_cherchee : # 3 return True if valeur_centrale < valeur_cherchee : # 4 indice_debut = indice_central + 1 else : indice_fin = indice_central - 1 return False # 5 on calcule l'indice central on d\u00e9termine la valeur centrale si la valeur centrale est la valeur cherch\u00e9e... si la valeur centrale est trop petite... la valeur_cherchee ne se trouve pas dans tableau Exemple d'utilisation : >>> t = [ 2 , 3 , 6 , 7 , 11 , 14 , 18 , 19 , 24 ] >>> recherche_dichotomique ( t , 7 ) True >>> recherche_dichotomique ( t , 35 ) False \u00c0 chaque tour de la boucle while , la taille de la liste est divis\u00e9e par 2. Ceci conf\u00e8re \u00e0 cet algorithme une complexit\u00e9 logarithmique (bien meilleure qu'une complexit\u00e9 lin\u00e9aire).","title":"1.1. Version imp\u00e9rative"},{"location":"Diviser%20pour%20r%C3%A9gner/cours/#12-version-recursive","text":"Il est possible de programmer de mani\u00e8re r\u00e9cursive la recherche dichotomique sans toucher au tableau, comme on pourrait le faire en utilisant le slicing, et donc en jouant uniquement sur les indices : Dichotomie version r\u00e9cursive 1 2 3 4 5 6 7 8 9 10 11 12 def dicho_rec ( tableau , valeur_cherchee , indice_debut = 0 , indice_fin = None ): if indice_fin is None : indice_fin = len ( tableau ) - 1 if indice_debut > indice_fin : return False indice_central = ( indice_debut + indice_fin ) // 2 if tableau [ indice_central ] < valeur_cherchee : return dicho_rec ( tableau , valeur_cherchee , indice_central + 1 , indice_fin ) elif tableau [ indice_central ] > valeur_cherchee : return dicho_rec ( tableau , valeur_cherchee , indice_debut , indice_central - 1 ) else : return True Pour pouvoir appeler simplement la fonction sans avoir \u00e0 pr\u00e9ciser les indices, on leur donne des param\u00e8tres par d\u00e9faut. Il est impossible de donner indice_fin = len(tableau) - 1 par d\u00e9faut (car tableau est aussi un param\u00e8tre). On passe donc par une autre valeur (ici None ) qu'on va ici intercepter. Exemple d'utilisation : >>> t = [ 2 , 3 , 6 , 7 , 11 , 14 , 18 , 19 , 24 ] >>> dicho_rec ( t , 7 ) True >>> dicho_rec ( t , 35 ) False Visualisation gr\u00e2ce \u00e0 PythonTutor:","title":"1.2. Version r\u00e9cursive"},{"location":"Diviser%20pour%20r%C3%A9gner/cours/#2-diviser-pour-regner","text":"Les algorithmes de dichotomie pr\u00e9sent\u00e9s ci-dessus ont tous en commun de diviser par deux la taille des donn\u00e9es de travail \u00e0 chaque \u00e9tape. Cette m\u00e9thode de r\u00e9solution d'un probl\u00e8me est connue sous le nom de diviser pour r\u00e9gner , ou divide and conquer en anglais. Une d\u00e9finition pourrait \u00eatre : D\u00e9finition Un probl\u00e8me peut se r\u00e9soudre en employant le paradigme diviser pour r\u00e9gner lorsque : - il est possible de d\u00e9composer ce probl\u00e8me en sous-probl\u00e8mes ind\u00e9pendants - la taille de ces sous-probl\u00e8mes est une fraction du probl\u00e8me initial Remarques : Les sous-probl\u00e8mes peuvent n\u00e9cessiter d'\u00eatre ensuite recombin\u00e9s entre eux (voir plus bas le tri fusion). Consid\u00e9rons l'\u00e9criture r\u00e9cursive de la fonction factorielle ci-dessous : def factorielle ( n ): if n == 0 : return 1 else : return n * factorielle ( n - 1 ) On ne peut pas parler ici de diviser pour r\u00e9gner car la taille des donn\u00e9es \u00e0 traiter est pass\u00e9e de n \u00e0 n-1 . C'est bien une diminution (qui fait que l'algorithme fonctionne) mais il n'y a pas de division de la taille des donn\u00e9es. C'est cette division (par 2 dans le cas de la dichotomie) qui donne son efficacit\u00e9 \u00e0 ce paradigme. Le paradigme diviser pour r\u00e9gner va naturellement amener \u00e0 r\u00e9diger des programmes r\u00e9cursifs.","title":"2. Diviser pour r\u00e9gner"},{"location":"Diviser%20pour%20r%C3%A9gner/cours/#3-lexponentiation-rapide","text":"On appelle exponentiation le fait de mettre en puissance un nombre. On va donc coder, de deux mani\u00e8res diff\u00e9rentes, la puissance d'un nombre.","title":"3. L'exponentiation rapide"},{"location":"Diviser%20pour%20r%C3%A9gner/cours/#31-algorithme-classique","text":"Exponentiation classique 1 2 3 4 5 def puissance ( a , n ): if n == 0 : return 1 else : return a * puissance ( a , n - 1 )","title":"3.1. Algorithme classique"},{"location":"Diviser%20pour%20r%C3%A9gner/cours/#32-algorithme-utilisant-diviser-pour-regner","text":"Nous allons nous appuyer sur la remarque math\u00e9matique suivante : Pour tout nombre \\(a\\) , si \\(n\\) est pair, \\(a^n = (a^2)^{\\frac{n}{2}}\\) si \\(n\\) est impair, \\(a^n = a \\times a^{n-1} = a \\times (a^2)^{\\frac{n-1}{2}}\\) Ainsi, dans le cas o\u00f9 \\(n\\) est pair, il suffit d'\u00e9lever \\(a\\) au carr\u00e9 (une seule op\u00e9ration) pour que l'exposant diminue de moiti\u00e9 . On peut donc programmer la fonction puissance en utilisant le paradigme diviser pour r\u00e9gner : Exponentiation rapide 1 2 3 4 5 6 7 def puissance_mod ( a , n ): if n == 0 : return 1 if n % 2 == 0 : return puissance_mod ( a ** 2 , n // 2 ) else : return a * puissance_mod ( a ** 2 , ( n - 1 ) // 2 )","title":"3.2. Algorithme utilisant diviser pour r\u00e9gner"},{"location":"Diviser%20pour%20r%C3%A9gner/cours/#33-comparaison-de-la-vitesse-dexecution-des-deux-algorithmes","text":"Exercice \u00c9nonc\u00e9 Recr\u00e9er le graphique ci-dessus, qui compare les temps d'ex\u00e9cution des deux fonctions puissance et puissance_mod . Aide pour Matplotlib : le code ci-dessous 1 2 3 4 5 6 7 8 9 import matplotlib.pyplot as plt def carre ( x ): return x ** 2 x = list ( range ( 10 )) y = [ carre ( k ) for k in x ] plt . plot ( x , y ) plt . show () donne le graphique suivant :","title":"3.3. Comparaison de la vitesse d'ex\u00e9cution des deux algorithmes"},{"location":"Diviser%20pour%20r%C3%A9gner/cours/#4-le-tri-fusion","text":"En anglais le merge sort .","title":"4. Le tri-fusion"},{"location":"Diviser%20pour%20r%C3%A9gner/cours/#41-preambule-linterclassement","text":"Le m\u00e9canisme principal du tri fusion est la fusion de deux listes tri\u00e9es en une nouvelle liste elle aussi tri\u00e9e. On appelera ce m\u00e9canisme l' interclassement . Principe de l'interclassement de deux listes lst1 et lst2 . on part d'une liste vide lst_totale on y ajoute alternativement les \u00e9l\u00e9ments de lst1 et lst2 . Il faut pour cela g\u00e9rer s\u00e9par\u00e9ment un indice i1 pour la liste lst1 et un indice i2 pour la liste i2 . quand une liste est \u00e9puis\u00e9e, on y ajoute la totalit\u00e9 restante de l'autre liste. Exercice \u00c9nonc\u00e9 Correction Coder la fonction interclassement . def interclassement ( lst1 , lst2 ): i1 = 0 i2 = 0 lst_totale = [] while i1 != len ( lst1 ) and i2 != len ( lst2 ): if lst1 [ i1 ] < lst2 [ i2 ]: lst_totale . append ( lst1 [ i1 ]) i1 += 1 else : lst_totale . append ( lst2 [ i2 ]) i2 += 1 return lst_totale + lst1 [ i1 :] + lst2 [ i2 :]","title":"4.1. Pr\u00e9ambule : l'interclassement"},{"location":"Diviser%20pour%20r%C3%A9gner/cours/#42-la-fusion","text":"","title":"4.2. La fusion"},{"location":"Diviser%20pour%20r%C3%A9gner/cours/#43-complexite","text":"La division par 2 de la taille de la liste pourrait nous amener \u00e0 penser que le tri fusion est de complexit\u00e9 logarithmique, comme l'algorithme de dichotomie. Il n'en est rien. En effet, l'instruction finale interclassement(tri_fusion(lst[:m]), tri_fusion(lst[m:])) lance deux appels \u00e0 la fonction tri_fusion (avec certe des donn\u00e9es d'entr\u00e9e deux fois plus petites). On peut montrer que : Complexit\u00e9 du tri fusion L'algorithme de tri fusion est en \\(O(n \\log n)\\) . On dit qu'il est semi-logarithmique . Une complexit\u00e9 semi-logarithmique (en \\(O(n \\log n)\\) ) se situe \u00abentre\u00bb une complexit\u00e9 lin\u00e9aire (en \\(O(n)\\) ) et une complexit\u00e9 quadratique (en \\(O(n^2)\\) ).","title":"4.3. Complexit\u00e9"},{"location":"VM/cours/","text":"Utilisation de machines virtuelles (VM) au lyc\u00e9e \u2693\ufe0e Principe \u2693\ufe0e Afin de pouvoir travailler sous le syst\u00e8me d'exploitation libre GNU / Linux sur les machines du lyc\u00e9e (sous Windows), nous utilisons la solution de virtualisation Proxmox. Elle est fournie par la R\u00e9gion qui ex\u00e9cute Proxmox sur un serveur, cet environnement virtualis\u00e9 est organis\u00e9 sous forme de bulle isol\u00e9e du r\u00e9seau p\u00e9dagogique du lyc\u00e9e mais pas d'Internet. De mani\u00e8re simplifi\u00e9e : un serveur (assez puissant) se trouve dans la salle serveur du lyc\u00e9e ; sur ce serveur, un grand nombre de syst\u00e8mes d'exploitation peuvent \u00eatre d\u00e9marr\u00e9s ind\u00e9pendamment ; une VM est disponible par \u00e9l\u00e8ve : c'est sa machine virtuelle (VM : Virtual Machine) ex\u00e9cut\u00e9e sur le serveur Proxmox du lyc\u00e9e ; l'\u00e9l\u00e8ve se connecte \u00e0 sa VM depuis un navigateur de n'importe quel ordinateur du lyc\u00e9e ; cet ordinateur (le client) ne va faire que recevoir le flux vid\u00e9o venu du serveur Proxmox et lui envoyer les interactions utilisateurs : clavier et souris ; en mettant ce flux vid\u00e9o en plein \u00e9cran, on a l'illusion d'\u00eatre sous un nouveau syst\u00e8me d'exploitation. Nous allons donc travailler sous Linux, tout en restant en r\u00e9alit\u00e9 sur Windows ; chaque \u00e9l\u00e8ve a acc\u00e8s \u00e0 Internet en entrant ses identifiants et mot de passe habituels du r\u00e9seau p\u00e9dagogique sur une application nomm\u00e9e ALCASAR (Application Libre pour le Contr\u00f4le d'Accc\u00e8s S\u00e9curis\u00e9 et Authentifi\u00e9 au R\u00e9seau). Proc\u00e9dure \u00e0 suivre pour ouvrir utiliser sa VM \u2693\ufe0e Ouvrir le navigateur Firefox et entrer l'adresse suivante : https://172.18.107.248:8006 Une alerte de s\u00e9curit\u00e9 appara\u00eet : Cliquer sur Avanc\u00e9... , un autre message s'affiche en-dessous : Cliquer sur Accepter le risque et poursuivre La fen\u00eatre de connexion Proxmox VE Login s'ouvre : Avant de renseigner son nom d'utilisateur et son mot de passe, il faut s\u00e9lectionner dans Realm : Proxmox VE authentication server et dans Langue : French , la fen\u00eatre est maintenant intitul\u00e9e Authentication Proxmox VE comme ci-dessous : Renseigner son nom d'utilisateur Proxmox et son mot de passe puis cliquer sur Login (les identifiants Proxmox sont donn\u00e9s par le prof). Un message d'avertissement appara\u00eet (\"Aucune cl\u00e9 d'enregistrement valide\"). Cliquer OK pour l'ignorer. Dans la colonne de gauche de la page Proxmox , s\u00e9lectionner sa machine virtuelle (VM) sous Datacenter > SVR-10-ORN , exemple 112(XUB1) En haut \u00e0 droite de la page Proxmox , cliquer sur D\u00e9marrer pour d\u00e9marrer la VM (ou clic droit sur la VM puis s\u00e9lectionner D\u00e9marrer ) Cliquer sur le bouton Console et choisir Spice (ou clic droit sur la VM puis s\u00e9lectionner Console ). La fen\u00eatre ci-dessous s'affiche : Cliquer OK et attendre un peu. Si rien ne se passe au bout d'une dizaine de secondes, fermer la fen\u00eatre et cliquer de nouveau sur Spice puis sur OK . Si tout s'est bien pass\u00e9, le client de connexion Spice permet d'obtenir la distribution Linux : Xubuntu ex\u00e9cut\u00e9e par la machine virtuelle. Renseigner ses identifiants dans la fen\u00eatre de connexion \u00e0 Xubuntu , si la connexion n'est pas automatique : login : test mot de passe : nsispeinfo Ainsi, chaque \u00e9l\u00e8ve a pour nom d'utilisateur test dans Xubuntu Basculer l'affichage en plein \u00e9cran en cliquant sur en haut \u00e0 droite dans Spice . Au premier lancement de Firefox sur Xubuntu , cliquer sur Afficher la page de connexion du r\u00e9seau Remplir ses identifiants de session Windows, pour \u00eatre autoris\u00e9 \u00e0 acc\u00e9der au r\u00e9seau Internet par l'interm\u00e9diaire d'ALCASAR-ORN : S'ouvre alors une fen\u00eatre qui pr\u00e9vient \"Attention : vous serez d\u00e9connect\u00e9 si vous fermez cette fen\u00eatre\". Utiliser alors un autre onglet du navigateur pour aller sur Lyc\u00e9e connect\u00e9 par exemple. Pour arr\u00eater une VM, faire simplement une d\u00e9connexion en cliquant sur l'ic\u00f4ne bleu en haut \u00e0 gauche du bureau Xubuntu puis choisir d'\u00e9teindre. Ainsi, dans la page Proxmox , on verra bien que la VM est stopp\u00e9e. Pour se d\u00e9connecter de Proxmox , aller en haut \u00e0 droite de la fen\u00eatre et cliquer sur la fl\u00eache du bas puis sur D\u00e9connexion Remarque : dans cette version de Proxmox associ\u00e9e \u00e0 Windows 10, l'utilisateur n'a pas acc\u00e8s au port USB, on ne peut pas donc utiliser de cl\u00e9 USB ni programmer de carte micro:bit ou Arduino. Pour r\u00e9cup\u00e9rer ou enregistrer des fichiers, on pourra utiliser Documents et Documents partag\u00e9s de Lyc\u00e9e connect\u00e9 .","title":"Utilisation de machines virtuelles (VM) au lyc\u00e9e"},{"location":"VM/cours/#utilisation-de-machines-virtuelles-vm-au-lycee","text":"","title":"Utilisation de machines virtuelles (VM) au lyc\u00e9e"},{"location":"VM/cours/#principe","text":"Afin de pouvoir travailler sous le syst\u00e8me d'exploitation libre GNU / Linux sur les machines du lyc\u00e9e (sous Windows), nous utilisons la solution de virtualisation Proxmox. Elle est fournie par la R\u00e9gion qui ex\u00e9cute Proxmox sur un serveur, cet environnement virtualis\u00e9 est organis\u00e9 sous forme de bulle isol\u00e9e du r\u00e9seau p\u00e9dagogique du lyc\u00e9e mais pas d'Internet. De mani\u00e8re simplifi\u00e9e : un serveur (assez puissant) se trouve dans la salle serveur du lyc\u00e9e ; sur ce serveur, un grand nombre de syst\u00e8mes d'exploitation peuvent \u00eatre d\u00e9marr\u00e9s ind\u00e9pendamment ; une VM est disponible par \u00e9l\u00e8ve : c'est sa machine virtuelle (VM : Virtual Machine) ex\u00e9cut\u00e9e sur le serveur Proxmox du lyc\u00e9e ; l'\u00e9l\u00e8ve se connecte \u00e0 sa VM depuis un navigateur de n'importe quel ordinateur du lyc\u00e9e ; cet ordinateur (le client) ne va faire que recevoir le flux vid\u00e9o venu du serveur Proxmox et lui envoyer les interactions utilisateurs : clavier et souris ; en mettant ce flux vid\u00e9o en plein \u00e9cran, on a l'illusion d'\u00eatre sous un nouveau syst\u00e8me d'exploitation. Nous allons donc travailler sous Linux, tout en restant en r\u00e9alit\u00e9 sur Windows ; chaque \u00e9l\u00e8ve a acc\u00e8s \u00e0 Internet en entrant ses identifiants et mot de passe habituels du r\u00e9seau p\u00e9dagogique sur une application nomm\u00e9e ALCASAR (Application Libre pour le Contr\u00f4le d'Accc\u00e8s S\u00e9curis\u00e9 et Authentifi\u00e9 au R\u00e9seau).","title":"Principe"},{"location":"VM/cours/#procedure-a-suivre-pour-ouvrir-utiliser-sa-vm","text":"Ouvrir le navigateur Firefox et entrer l'adresse suivante : https://172.18.107.248:8006 Une alerte de s\u00e9curit\u00e9 appara\u00eet : Cliquer sur Avanc\u00e9... , un autre message s'affiche en-dessous : Cliquer sur Accepter le risque et poursuivre La fen\u00eatre de connexion Proxmox VE Login s'ouvre : Avant de renseigner son nom d'utilisateur et son mot de passe, il faut s\u00e9lectionner dans Realm : Proxmox VE authentication server et dans Langue : French , la fen\u00eatre est maintenant intitul\u00e9e Authentication Proxmox VE comme ci-dessous : Renseigner son nom d'utilisateur Proxmox et son mot de passe puis cliquer sur Login (les identifiants Proxmox sont donn\u00e9s par le prof). Un message d'avertissement appara\u00eet (\"Aucune cl\u00e9 d'enregistrement valide\"). Cliquer OK pour l'ignorer. Dans la colonne de gauche de la page Proxmox , s\u00e9lectionner sa machine virtuelle (VM) sous Datacenter > SVR-10-ORN , exemple 112(XUB1) En haut \u00e0 droite de la page Proxmox , cliquer sur D\u00e9marrer pour d\u00e9marrer la VM (ou clic droit sur la VM puis s\u00e9lectionner D\u00e9marrer ) Cliquer sur le bouton Console et choisir Spice (ou clic droit sur la VM puis s\u00e9lectionner Console ). La fen\u00eatre ci-dessous s'affiche : Cliquer OK et attendre un peu. Si rien ne se passe au bout d'une dizaine de secondes, fermer la fen\u00eatre et cliquer de nouveau sur Spice puis sur OK . Si tout s'est bien pass\u00e9, le client de connexion Spice permet d'obtenir la distribution Linux : Xubuntu ex\u00e9cut\u00e9e par la machine virtuelle. Renseigner ses identifiants dans la fen\u00eatre de connexion \u00e0 Xubuntu , si la connexion n'est pas automatique : login : test mot de passe : nsispeinfo Ainsi, chaque \u00e9l\u00e8ve a pour nom d'utilisateur test dans Xubuntu Basculer l'affichage en plein \u00e9cran en cliquant sur en haut \u00e0 droite dans Spice . Au premier lancement de Firefox sur Xubuntu , cliquer sur Afficher la page de connexion du r\u00e9seau Remplir ses identifiants de session Windows, pour \u00eatre autoris\u00e9 \u00e0 acc\u00e9der au r\u00e9seau Internet par l'interm\u00e9diaire d'ALCASAR-ORN : S'ouvre alors une fen\u00eatre qui pr\u00e9vient \"Attention : vous serez d\u00e9connect\u00e9 si vous fermez cette fen\u00eatre\". Utiliser alors un autre onglet du navigateur pour aller sur Lyc\u00e9e connect\u00e9 par exemple. Pour arr\u00eater une VM, faire simplement une d\u00e9connexion en cliquant sur l'ic\u00f4ne bleu en haut \u00e0 gauche du bureau Xubuntu puis choisir d'\u00e9teindre. Ainsi, dans la page Proxmox , on verra bien que la VM est stopp\u00e9e. Pour se d\u00e9connecter de Proxmox , aller en haut \u00e0 droite de la fen\u00eatre et cliquer sur la fl\u00eache du bas puis sur D\u00e9connexion Remarque : dans cette version de Proxmox associ\u00e9e \u00e0 Windows 10, l'utilisateur n'a pas acc\u00e8s au port USB, on ne peut pas donc utiliser de cl\u00e9 USB ni programmer de carte micro:bit ou Arduino. Pour r\u00e9cup\u00e9rer ou enregistrer des fichiers, on pourra utiliser Documents et Documents partag\u00e9s de Lyc\u00e9e connect\u00e9 .","title":"Proc\u00e9dure \u00e0 suivre pour ouvrir utiliser sa VM"}]}